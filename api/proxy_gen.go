// Code generated by github.com/filecoin-project/curio/api/gen. DO NOT EDIT.

package api

import (
	"context"
	mathbig "math/big"
	"net/http"
	"net/url"
	"reflect"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/common"
	ethtypes "github.com/ethereum/go-ethereum/core/types"
	erpc "github.com/ethereum/go-ethereum/rpc"
	"github.com/google/uuid"
	blocks "github.com/ipfs/go-block-format"
	"github.com/ipfs/go-cid"
	"github.com/multiformats/go-multihash"
	"golang.org/x/xerrors"

	"github.com/filecoin-project/go-address"
	"github.com/filecoin-project/go-bitfield"
	"github.com/filecoin-project/go-jsonrpc/auth"
	"github.com/filecoin-project/go-state-types/abi"
	"github.com/filecoin-project/go-state-types/big"
	verifregtypes "github.com/filecoin-project/go-state-types/builtin/v9/verifreg"
	"github.com/filecoin-project/go-state-types/crypto"
	"github.com/filecoin-project/go-state-types/dline"
	"github.com/filecoin-project/go-state-types/network"

	ltypes "github.com/filecoin-project/curio/api/types"
	"github.com/filecoin-project/curio/lib/storiface"

	"github.com/filecoin-project/lotus/api"
	"github.com/filecoin-project/lotus/chain/actors/builtin/miner"
	"github.com/filecoin-project/lotus/chain/types"
	"github.com/filecoin-project/lotus/node/modules/dtypes"
	lpiece "github.com/filecoin-project/lotus/storage/pipeline/piece"
	"github.com/filecoin-project/lotus/storage/sealer/fsutil"
)

var _ = reflect.TypeOf([]byte(nil))
var ErrNotSupported = xerrors.New("method not supported")

type CurioStruct struct {
	Internal CurioMethods
}

type CurioMethods struct {
	AllocatePieceToSector func(p0 context.Context, p1 address.Address, p2 lpiece.PieceDealInfo, p3 int64, p4 url.URL, p5 http.Header) (api.SectorOffset, error) `perm:"write"`

	Cordon func(p0 context.Context) error `perm:"admin"`

	IndexSamples func(p0 context.Context, p1 cid.Cid) ([]multihash.Multihash, error) `perm:"admin"`

	Info func(p0 context.Context) (*ltypes.NodeInfo, error) `perm:"read"`

	LogList func(p0 context.Context) ([]string, error) `perm:"read"`

	LogSetLevel func(p0 context.Context, p1 string, p2 string) error `perm:"admin"`

	Shutdown func(p0 context.Context) error `perm:"admin"`

	StorageAddLocal func(p0 context.Context, p1 string) error `perm:"admin"`

	StorageDetachLocal func(p0 context.Context, p1 string) error `perm:"admin"`

	StorageFindSector func(p0 context.Context, p1 abi.SectorID, p2 storiface.SectorFileType, p3 abi.SectorSize, p4 bool) ([]storiface.SectorStorageInfo, error) `perm:"admin"`

	StorageGenerateVanillaProof func(p0 context.Context, p1 address.Address, p2 abi.SectorNumber) ([]byte, error) `perm:"admin"`

	StorageInfo func(p0 context.Context, p1 storiface.ID) (storiface.StorageInfo, error) `perm:"admin"`

	StorageInit func(p0 context.Context, p1 string, p2 storiface.LocalStorageMeta) error `perm:"admin"`

	StorageList func(p0 context.Context) (map[storiface.ID][]storiface.Decl, error) `perm:"admin"`

	StorageLocal func(p0 context.Context) (map[storiface.ID]string, error) `perm:"admin"`

	StorageRedeclare func(p0 context.Context, p1 *storiface.ID, p2 bool) error `perm:"admin"`

	StorageStat func(p0 context.Context, p1 storiface.ID) (fsutil.FsStat, error) `perm:"admin"`

	Uncordon func(p0 context.Context) error `perm:"admin"`

	Version func(p0 context.Context) ([]int, error) `perm:"admin"`
}

type CurioStub struct {
}

type CurioChainRPCStruct struct {
	Internal CurioChainRPCMethods
}

type CurioChainRPCMethods struct {
	AuthNew func(p0 context.Context, p1 []auth.Permission) ([]byte, error) `perm:"admin"`

	AuthVerify func(p0 context.Context, p1 string) ([]auth.Permission, error) `perm:"read"`

	ChainGetMessage func(p0 context.Context, p1 cid.Cid) (*types.Message, error) ``

	ChainGetTipSet func(p0 context.Context, p1 types.TipSetKey) (*types.TipSet, error) ``

	ChainGetTipSetAfterHeight func(p0 context.Context, p1 abi.ChainEpoch, p2 types.TipSetKey) (*types.TipSet, error) ``

	ChainGetTipSetByHeight func(p0 context.Context, p1 abi.ChainEpoch, p2 types.TipSetKey) (*types.TipSet, error) ``

	ChainHasObj func(p0 context.Context, p1 cid.Cid) (bool, error) ``

	ChainHead func(p0 context.Context) (*types.TipSet, error) ``

	ChainNotify func(p0 context.Context) (<-chan []*api.HeadChange, error) ``

	ChainPutObj func(p0 context.Context, p1 blocks.Block) error ``

	ChainReadObj func(p0 context.Context, p1 cid.Cid) ([]byte, error) ``

	ChainTipSetWeight func(p0 context.Context, p1 types.TipSetKey) (types.BigInt, error) ``

	GasEstimateFeeCap func(p0 context.Context, p1 *types.Message, p2 int64, p3 types.TipSetKey) (types.BigInt, error) ``

	GasEstimateGasPremium func(p0 context.Context, p1 uint64, p2 address.Address, p3 int64, p4 types.TipSetKey) (types.BigInt, error) ``

	GasEstimateMessageGas func(p0 context.Context, p1 *types.Message, p2 *api.MessageSendSpec, p3 types.TipSetKey) (*types.Message, error) ``

	MarketAddBalance func(p0 context.Context, p1 address.Address, p2 address.Address, p3 types.BigInt) (cid.Cid, error) ``

	MinerCreateBlock func(p0 context.Context, p1 *api.BlockTemplate) (*types.BlockMsg, error) ``

	MinerGetBaseInfo func(p0 context.Context, p1 address.Address, p2 abi.ChainEpoch, p3 types.TipSetKey) (*api.MiningBaseInfo, error) ``

	MpoolGetNonce func(p0 context.Context, p1 address.Address) (uint64, error) ``

	MpoolPush func(p0 context.Context, p1 *types.SignedMessage) (cid.Cid, error) ``

	MpoolPushMessage func(p0 context.Context, p1 *types.Message, p2 *api.MessageSendSpec) (*types.SignedMessage, error) ``

	MpoolSelect func(p0 context.Context, p1 types.TipSetKey, p2 float64) ([]*types.SignedMessage, error) ``

	Session func(p0 context.Context) (uuid.UUID, error) `perm:"read"`

	Shutdown func(p0 context.Context) error `perm:"admin"`

	StateAccountKey func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (address.Address, error) ``

	StateCall func(p0 context.Context, p1 *types.Message, p2 types.TipSetKey) (*api.InvocResult, error) ``

	StateCirculatingSupply func(p0 context.Context, p1 types.TipSetKey) (big.Int, error) ``

	StateDealProviderCollateralBounds func(p0 context.Context, p1 abi.PaddedPieceSize, p2 bool, p3 types.TipSetKey) (api.DealCollateralBounds, error) ``

	StateGetActor func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*types.Actor, error) ``

	StateGetAllocation func(p0 context.Context, p1 address.Address, p2 verifregtypes.AllocationId, p3 types.TipSetKey) (*verifregtypes.Allocation, error) ``

	StateGetAllocationForPendingDeal func(p0 context.Context, p1 abi.DealID, p2 types.TipSetKey) (*verifregtypes.Allocation, error) ``

	StateGetAllocationIdForPendingDeal func(p0 context.Context, p1 abi.DealID, p2 types.TipSetKey) (verifregtypes.AllocationId, error) ``

	StateGetBeaconEntry func(p0 context.Context, p1 abi.ChainEpoch) (*types.BeaconEntry, error) ``

	StateGetRandomnessFromBeacon func(p0 context.Context, p1 crypto.DomainSeparationTag, p2 abi.ChainEpoch, p3 []byte, p4 types.TipSetKey) (abi.Randomness, error) ``

	StateGetRandomnessFromTickets func(p0 context.Context, p1 crypto.DomainSeparationTag, p2 abi.ChainEpoch, p3 []byte, p4 types.TipSetKey) (abi.Randomness, error) ``

	StateListMessages func(p0 context.Context, p1 *api.MessageMatch, p2 types.TipSetKey, p3 abi.ChainEpoch) ([]cid.Cid, error) ``

	StateListMiners func(p0 context.Context, p1 types.TipSetKey) ([]address.Address, error) ``

	StateLookupID func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (address.Address, error) ``

	StateMarketBalance func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (api.MarketBalance, error) ``

	StateMarketStorageDeal func(p0 context.Context, p1 abi.DealID, p2 types.TipSetKey) (*api.MarketDeal, error) ``

	StateMinerActiveSectors func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) ([]*miner.SectorOnChainInfo, error) ``

	StateMinerAllocated func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*bitfield.BitField, error) ``

	StateMinerAvailableBalance func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (types.BigInt, error) `perm:"read"`

	StateMinerCreationDeposit func(p0 context.Context, p1 types.TipSetKey) (types.BigInt, error) ``

	StateMinerDeadlines func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) ([]api.Deadline, error) `perm:"read"`

	StateMinerFaults func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (bitfield.BitField, error) ``

	StateMinerInfo func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (api.MinerInfo, error) ``

	StateMinerInitialPledgeForSector func(p0 context.Context, p1 abi.ChainEpoch, p2 abi.SectorSize, p3 uint64, p4 types.TipSetKey) (types.BigInt, error) ``

	StateMinerPartitions func(p0 context.Context, p1 address.Address, p2 uint64, p3 types.TipSetKey) ([]api.Partition, error) ``

	StateMinerPower func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*api.MinerPower, error) `perm:"read"`

	StateMinerPreCommitDepositForPower func(p0 context.Context, p1 address.Address, p2 miner.SectorPreCommitInfo, p3 types.TipSetKey) (big.Int, error) ``

	StateMinerProvingDeadline func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*dline.Info, error) ``

	StateMinerRecoveries func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (bitfield.BitField, error) ``

	StateMinerSectorCount func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (api.MinerSectors, error) ``

	StateMinerSectors func(p0 context.Context, p1 address.Address, p2 *bitfield.BitField, p3 types.TipSetKey) ([]*miner.SectorOnChainInfo, error) ``

	StateNetworkName func(p0 context.Context) (dtypes.NetworkName, error) ``

	StateNetworkVersion func(p0 context.Context, p1 types.TipSetKey) (network.Version, error) ``

	StateReadState func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*api.ActorState, error) ``

	StateSearchMsg func(p0 context.Context, p1 types.TipSetKey, p2 cid.Cid, p3 abi.ChainEpoch, p4 bool) (*api.MsgLookup, error) ``

	StateSectorGetInfo func(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*miner.SectorOnChainInfo, error) ``

	StateSectorPartition func(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*miner.SectorLocation, error) ``

	StateSectorPreCommitInfo func(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*miner.SectorPreCommitOnChainInfo, error) ``

	StateVMCirculatingSupplyInternal func(p0 context.Context, p1 types.TipSetKey) (api.CirculatingSupply, error) ``

	StateVerifiedClientStatus func(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*abi.StoragePower, error) ``

	StateWaitMsg func(p0 context.Context, p1 cid.Cid, p2 uint64, p3 abi.ChainEpoch, p4 bool) (*api.MsgLookup, error) `perm:"read"`

	SyncSubmitBlock func(p0 context.Context, p1 *types.BlockMsg) error ``

	Version func(p0 context.Context) (api.APIVersion, error) `perm:"read"`

	WalletBalance func(p0 context.Context, p1 address.Address) (big.Int, error) ``

	WalletHas func(p0 context.Context, p1 address.Address) (bool, error) ``

	WalletSign func(p0 context.Context, p1 address.Address, p2 []byte) (*crypto.Signature, error) ``

	WalletSignMessage func(p0 context.Context, p1 address.Address, p2 *types.Message) (*types.SignedMessage, error) ``
}

type CurioChainRPCStub struct {
}

type EthClientInterfaceStruct struct {
	Internal EthClientInterfaceMethods
}

type EthClientInterfaceMethods struct {
	BalanceAt func(p0 context.Context, p1 common.Address, p2 *mathbig.Int) (*mathbig.Int, error) ``

	BalanceAtHash func(p0 context.Context, p1 common.Address, p2 common.Hash) (*mathbig.Int, error) ``

	BlockByHash func(p0 context.Context, p1 common.Hash) (*ethtypes.Block, error) ``

	BlockByNumber func(p0 context.Context, p1 *mathbig.Int) (*ethtypes.Block, error) ``

	BlockNumber func(p0 context.Context) (uint64, error) ``

	BlockReceipts func(p0 context.Context, p1 erpc.BlockNumberOrHash) ([]*ethtypes.Receipt, error) ``

	CallContract func(p0 context.Context, p1 ethereum.CallMsg, p2 *mathbig.Int) ([]byte, error) ``

	CallContractAtHash func(p0 context.Context, p1 ethereum.CallMsg, p2 common.Hash) ([]byte, error) ``

	ChainID func(p0 context.Context) (*mathbig.Int, error) ``

	CodeAt func(p0 context.Context, p1 common.Address, p2 *mathbig.Int) ([]byte, error) ``

	CodeAtHash func(p0 context.Context, p1 common.Address, p2 common.Hash) ([]byte, error) ``

	EstimateGas func(p0 context.Context, p1 ethereum.CallMsg) (uint64, error) ``

	FeeHistory func(p0 context.Context, p1 uint64, p2 *mathbig.Int, p3 []float64) (*ethereum.FeeHistory, error) ``

	FilterLogs func(p0 context.Context, p1 ethereum.FilterQuery) ([]ethtypes.Log, error) ``

	HeaderByHash func(p0 context.Context, p1 common.Hash) (*ethtypes.Header, error) ``

	HeaderByNumber func(p0 context.Context, p1 *mathbig.Int) (*ethtypes.Header, error) ``

	NetworkID func(p0 context.Context) (*mathbig.Int, error) ``

	NonceAt func(p0 context.Context, p1 common.Address, p2 *mathbig.Int) (uint64, error) ``

	NonceAtHash func(p0 context.Context, p1 common.Address, p2 common.Hash) (uint64, error) ``

	PeerCount func(p0 context.Context) (uint64, error) ``

	PendingBalanceAt func(p0 context.Context, p1 common.Address) (*mathbig.Int, error) ``

	PendingCallContract func(p0 context.Context, p1 ethereum.CallMsg) ([]byte, error) ``

	PendingCodeAt func(p0 context.Context, p1 common.Address) ([]byte, error) ``

	PendingNonceAt func(p0 context.Context, p1 common.Address) (uint64, error) ``

	PendingStorageAt func(p0 context.Context, p1 common.Address, p2 common.Hash) ([]byte, error) ``

	PendingTransactionCount func(p0 context.Context) (uint, error) ``

	SendTransaction func(p0 context.Context, p1 *ethtypes.Transaction) error ``

	StorageAt func(p0 context.Context, p1 common.Address, p2 common.Hash, p3 *mathbig.Int) ([]byte, error) ``

	StorageAtHash func(p0 context.Context, p1 common.Address, p2 common.Hash, p3 common.Hash) ([]byte, error) ``

	SubscribeFilterLogs func(p0 context.Context, p1 ethereum.FilterQuery, p2 chan<- ethtypes.Log) (ethereum.Subscription, error) ``

	SubscribeNewHead func(p0 context.Context, p1 chan<- *ethtypes.Header) (ethereum.Subscription, error) ``

	SuggestGasPrice func(p0 context.Context) (*mathbig.Int, error) ``

	SuggestGasTipCap func(p0 context.Context) (*mathbig.Int, error) ``

	SyncProgress func(p0 context.Context) (*ethereum.SyncProgress, error) ``

	TransactionByHash func(p0 context.Context, p1 common.Hash) (*ethtypes.Transaction, bool, error) ``

	TransactionCount func(p0 context.Context, p1 common.Hash) (uint, error) ``

	TransactionInBlock func(p0 context.Context, p1 common.Hash, p2 uint) (*ethtypes.Transaction, error) ``

	TransactionReceipt func(p0 context.Context, p1 common.Hash) (*ethtypes.Receipt, error) ``

	TransactionSender func(p0 context.Context, p1 *ethtypes.Transaction, p2 common.Hash, p3 uint) (common.Address, error) ``
}

type EthClientInterfaceStub struct {
}

func (s *CurioStruct) AllocatePieceToSector(p0 context.Context, p1 address.Address, p2 lpiece.PieceDealInfo, p3 int64, p4 url.URL, p5 http.Header) (api.SectorOffset, error) {
	if s.Internal.AllocatePieceToSector == nil {
		return *new(api.SectorOffset), ErrNotSupported
	}
	return s.Internal.AllocatePieceToSector(p0, p1, p2, p3, p4, p5)
}

func (s *CurioStub) AllocatePieceToSector(p0 context.Context, p1 address.Address, p2 lpiece.PieceDealInfo, p3 int64, p4 url.URL, p5 http.Header) (api.SectorOffset, error) {
	return *new(api.SectorOffset), ErrNotSupported
}

func (s *CurioStruct) Cordon(p0 context.Context) error {
	if s.Internal.Cordon == nil {
		return ErrNotSupported
	}
	return s.Internal.Cordon(p0)
}

func (s *CurioStub) Cordon(p0 context.Context) error {
	return ErrNotSupported
}

func (s *CurioStruct) IndexSamples(p0 context.Context, p1 cid.Cid) ([]multihash.Multihash, error) {
	if s.Internal.IndexSamples == nil {
		return *new([]multihash.Multihash), ErrNotSupported
	}
	return s.Internal.IndexSamples(p0, p1)
}

func (s *CurioStub) IndexSamples(p0 context.Context, p1 cid.Cid) ([]multihash.Multihash, error) {
	return *new([]multihash.Multihash), ErrNotSupported
}

func (s *CurioStruct) Info(p0 context.Context) (*ltypes.NodeInfo, error) {
	if s.Internal.Info == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.Info(p0)
}

func (s *CurioStub) Info(p0 context.Context) (*ltypes.NodeInfo, error) {
	return nil, ErrNotSupported
}

func (s *CurioStruct) LogList(p0 context.Context) ([]string, error) {
	if s.Internal.LogList == nil {
		return *new([]string), ErrNotSupported
	}
	return s.Internal.LogList(p0)
}

func (s *CurioStub) LogList(p0 context.Context) ([]string, error) {
	return *new([]string), ErrNotSupported
}

func (s *CurioStruct) LogSetLevel(p0 context.Context, p1 string, p2 string) error {
	if s.Internal.LogSetLevel == nil {
		return ErrNotSupported
	}
	return s.Internal.LogSetLevel(p0, p1, p2)
}

func (s *CurioStub) LogSetLevel(p0 context.Context, p1 string, p2 string) error {
	return ErrNotSupported
}

func (s *CurioStruct) Shutdown(p0 context.Context) error {
	if s.Internal.Shutdown == nil {
		return ErrNotSupported
	}
	return s.Internal.Shutdown(p0)
}

func (s *CurioStub) Shutdown(p0 context.Context) error {
	return ErrNotSupported
}

func (s *CurioStruct) StorageAddLocal(p0 context.Context, p1 string) error {
	if s.Internal.StorageAddLocal == nil {
		return ErrNotSupported
	}
	return s.Internal.StorageAddLocal(p0, p1)
}

func (s *CurioStub) StorageAddLocal(p0 context.Context, p1 string) error {
	return ErrNotSupported
}

func (s *CurioStruct) StorageDetachLocal(p0 context.Context, p1 string) error {
	if s.Internal.StorageDetachLocal == nil {
		return ErrNotSupported
	}
	return s.Internal.StorageDetachLocal(p0, p1)
}

func (s *CurioStub) StorageDetachLocal(p0 context.Context, p1 string) error {
	return ErrNotSupported
}

func (s *CurioStruct) StorageFindSector(p0 context.Context, p1 abi.SectorID, p2 storiface.SectorFileType, p3 abi.SectorSize, p4 bool) ([]storiface.SectorStorageInfo, error) {
	if s.Internal.StorageFindSector == nil {
		return *new([]storiface.SectorStorageInfo), ErrNotSupported
	}
	return s.Internal.StorageFindSector(p0, p1, p2, p3, p4)
}

func (s *CurioStub) StorageFindSector(p0 context.Context, p1 abi.SectorID, p2 storiface.SectorFileType, p3 abi.SectorSize, p4 bool) ([]storiface.SectorStorageInfo, error) {
	return *new([]storiface.SectorStorageInfo), ErrNotSupported
}

func (s *CurioStruct) StorageGenerateVanillaProof(p0 context.Context, p1 address.Address, p2 abi.SectorNumber) ([]byte, error) {
	if s.Internal.StorageGenerateVanillaProof == nil {
		return *new([]byte), ErrNotSupported
	}
	return s.Internal.StorageGenerateVanillaProof(p0, p1, p2)
}

func (s *CurioStub) StorageGenerateVanillaProof(p0 context.Context, p1 address.Address, p2 abi.SectorNumber) ([]byte, error) {
	return *new([]byte), ErrNotSupported
}

func (s *CurioStruct) StorageInfo(p0 context.Context, p1 storiface.ID) (storiface.StorageInfo, error) {
	if s.Internal.StorageInfo == nil {
		return *new(storiface.StorageInfo), ErrNotSupported
	}
	return s.Internal.StorageInfo(p0, p1)
}

func (s *CurioStub) StorageInfo(p0 context.Context, p1 storiface.ID) (storiface.StorageInfo, error) {
	return *new(storiface.StorageInfo), ErrNotSupported
}

func (s *CurioStruct) StorageInit(p0 context.Context, p1 string, p2 storiface.LocalStorageMeta) error {
	if s.Internal.StorageInit == nil {
		return ErrNotSupported
	}
	return s.Internal.StorageInit(p0, p1, p2)
}

func (s *CurioStub) StorageInit(p0 context.Context, p1 string, p2 storiface.LocalStorageMeta) error {
	return ErrNotSupported
}

func (s *CurioStruct) StorageList(p0 context.Context) (map[storiface.ID][]storiface.Decl, error) {
	if s.Internal.StorageList == nil {
		return *new(map[storiface.ID][]storiface.Decl), ErrNotSupported
	}
	return s.Internal.StorageList(p0)
}

func (s *CurioStub) StorageList(p0 context.Context) (map[storiface.ID][]storiface.Decl, error) {
	return *new(map[storiface.ID][]storiface.Decl), ErrNotSupported
}

func (s *CurioStruct) StorageLocal(p0 context.Context) (map[storiface.ID]string, error) {
	if s.Internal.StorageLocal == nil {
		return *new(map[storiface.ID]string), ErrNotSupported
	}
	return s.Internal.StorageLocal(p0)
}

func (s *CurioStub) StorageLocal(p0 context.Context) (map[storiface.ID]string, error) {
	return *new(map[storiface.ID]string), ErrNotSupported
}

func (s *CurioStruct) StorageRedeclare(p0 context.Context, p1 *storiface.ID, p2 bool) error {
	if s.Internal.StorageRedeclare == nil {
		return ErrNotSupported
	}
	return s.Internal.StorageRedeclare(p0, p1, p2)
}

func (s *CurioStub) StorageRedeclare(p0 context.Context, p1 *storiface.ID, p2 bool) error {
	return ErrNotSupported
}

func (s *CurioStruct) StorageStat(p0 context.Context, p1 storiface.ID) (fsutil.FsStat, error) {
	if s.Internal.StorageStat == nil {
		return *new(fsutil.FsStat), ErrNotSupported
	}
	return s.Internal.StorageStat(p0, p1)
}

func (s *CurioStub) StorageStat(p0 context.Context, p1 storiface.ID) (fsutil.FsStat, error) {
	return *new(fsutil.FsStat), ErrNotSupported
}

func (s *CurioStruct) Uncordon(p0 context.Context) error {
	if s.Internal.Uncordon == nil {
		return ErrNotSupported
	}
	return s.Internal.Uncordon(p0)
}

func (s *CurioStub) Uncordon(p0 context.Context) error {
	return ErrNotSupported
}

func (s *CurioStruct) Version(p0 context.Context) ([]int, error) {
	if s.Internal.Version == nil {
		return *new([]int), ErrNotSupported
	}
	return s.Internal.Version(p0)
}

func (s *CurioStub) Version(p0 context.Context) ([]int, error) {
	return *new([]int), ErrNotSupported
}

func (s *CurioChainRPCStruct) AuthNew(p0 context.Context, p1 []auth.Permission) ([]byte, error) {
	if s.Internal.AuthNew == nil {
		return *new([]byte), ErrNotSupported
	}
	return s.Internal.AuthNew(p0, p1)
}

func (s *CurioChainRPCStub) AuthNew(p0 context.Context, p1 []auth.Permission) ([]byte, error) {
	return *new([]byte), ErrNotSupported
}

func (s *CurioChainRPCStruct) AuthVerify(p0 context.Context, p1 string) ([]auth.Permission, error) {
	if s.Internal.AuthVerify == nil {
		return *new([]auth.Permission), ErrNotSupported
	}
	return s.Internal.AuthVerify(p0, p1)
}

func (s *CurioChainRPCStub) AuthVerify(p0 context.Context, p1 string) ([]auth.Permission, error) {
	return *new([]auth.Permission), ErrNotSupported
}

func (s *CurioChainRPCStruct) ChainGetMessage(p0 context.Context, p1 cid.Cid) (*types.Message, error) {
	if s.Internal.ChainGetMessage == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.ChainGetMessage(p0, p1)
}

func (s *CurioChainRPCStub) ChainGetMessage(p0 context.Context, p1 cid.Cid) (*types.Message, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) ChainGetTipSet(p0 context.Context, p1 types.TipSetKey) (*types.TipSet, error) {
	if s.Internal.ChainGetTipSet == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.ChainGetTipSet(p0, p1)
}

func (s *CurioChainRPCStub) ChainGetTipSet(p0 context.Context, p1 types.TipSetKey) (*types.TipSet, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) ChainGetTipSetAfterHeight(p0 context.Context, p1 abi.ChainEpoch, p2 types.TipSetKey) (*types.TipSet, error) {
	if s.Internal.ChainGetTipSetAfterHeight == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.ChainGetTipSetAfterHeight(p0, p1, p2)
}

func (s *CurioChainRPCStub) ChainGetTipSetAfterHeight(p0 context.Context, p1 abi.ChainEpoch, p2 types.TipSetKey) (*types.TipSet, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) ChainGetTipSetByHeight(p0 context.Context, p1 abi.ChainEpoch, p2 types.TipSetKey) (*types.TipSet, error) {
	if s.Internal.ChainGetTipSetByHeight == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.ChainGetTipSetByHeight(p0, p1, p2)
}

func (s *CurioChainRPCStub) ChainGetTipSetByHeight(p0 context.Context, p1 abi.ChainEpoch, p2 types.TipSetKey) (*types.TipSet, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) ChainHasObj(p0 context.Context, p1 cid.Cid) (bool, error) {
	if s.Internal.ChainHasObj == nil {
		return false, ErrNotSupported
	}
	return s.Internal.ChainHasObj(p0, p1)
}

func (s *CurioChainRPCStub) ChainHasObj(p0 context.Context, p1 cid.Cid) (bool, error) {
	return false, ErrNotSupported
}

func (s *CurioChainRPCStruct) ChainHead(p0 context.Context) (*types.TipSet, error) {
	if s.Internal.ChainHead == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.ChainHead(p0)
}

func (s *CurioChainRPCStub) ChainHead(p0 context.Context) (*types.TipSet, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) ChainNotify(p0 context.Context) (<-chan []*api.HeadChange, error) {
	if s.Internal.ChainNotify == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.ChainNotify(p0)
}

func (s *CurioChainRPCStub) ChainNotify(p0 context.Context) (<-chan []*api.HeadChange, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) ChainPutObj(p0 context.Context, p1 blocks.Block) error {
	if s.Internal.ChainPutObj == nil {
		return ErrNotSupported
	}
	return s.Internal.ChainPutObj(p0, p1)
}

func (s *CurioChainRPCStub) ChainPutObj(p0 context.Context, p1 blocks.Block) error {
	return ErrNotSupported
}

func (s *CurioChainRPCStruct) ChainReadObj(p0 context.Context, p1 cid.Cid) ([]byte, error) {
	if s.Internal.ChainReadObj == nil {
		return *new([]byte), ErrNotSupported
	}
	return s.Internal.ChainReadObj(p0, p1)
}

func (s *CurioChainRPCStub) ChainReadObj(p0 context.Context, p1 cid.Cid) ([]byte, error) {
	return *new([]byte), ErrNotSupported
}

func (s *CurioChainRPCStruct) ChainTipSetWeight(p0 context.Context, p1 types.TipSetKey) (types.BigInt, error) {
	if s.Internal.ChainTipSetWeight == nil {
		return *new(types.BigInt), ErrNotSupported
	}
	return s.Internal.ChainTipSetWeight(p0, p1)
}

func (s *CurioChainRPCStub) ChainTipSetWeight(p0 context.Context, p1 types.TipSetKey) (types.BigInt, error) {
	return *new(types.BigInt), ErrNotSupported
}

func (s *CurioChainRPCStruct) GasEstimateFeeCap(p0 context.Context, p1 *types.Message, p2 int64, p3 types.TipSetKey) (types.BigInt, error) {
	if s.Internal.GasEstimateFeeCap == nil {
		return *new(types.BigInt), ErrNotSupported
	}
	return s.Internal.GasEstimateFeeCap(p0, p1, p2, p3)
}

func (s *CurioChainRPCStub) GasEstimateFeeCap(p0 context.Context, p1 *types.Message, p2 int64, p3 types.TipSetKey) (types.BigInt, error) {
	return *new(types.BigInt), ErrNotSupported
}

func (s *CurioChainRPCStruct) GasEstimateGasPremium(p0 context.Context, p1 uint64, p2 address.Address, p3 int64, p4 types.TipSetKey) (types.BigInt, error) {
	if s.Internal.GasEstimateGasPremium == nil {
		return *new(types.BigInt), ErrNotSupported
	}
	return s.Internal.GasEstimateGasPremium(p0, p1, p2, p3, p4)
}

func (s *CurioChainRPCStub) GasEstimateGasPremium(p0 context.Context, p1 uint64, p2 address.Address, p3 int64, p4 types.TipSetKey) (types.BigInt, error) {
	return *new(types.BigInt), ErrNotSupported
}

func (s *CurioChainRPCStruct) GasEstimateMessageGas(p0 context.Context, p1 *types.Message, p2 *api.MessageSendSpec, p3 types.TipSetKey) (*types.Message, error) {
	if s.Internal.GasEstimateMessageGas == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.GasEstimateMessageGas(p0, p1, p2, p3)
}

func (s *CurioChainRPCStub) GasEstimateMessageGas(p0 context.Context, p1 *types.Message, p2 *api.MessageSendSpec, p3 types.TipSetKey) (*types.Message, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) MarketAddBalance(p0 context.Context, p1 address.Address, p2 address.Address, p3 types.BigInt) (cid.Cid, error) {
	if s.Internal.MarketAddBalance == nil {
		return *new(cid.Cid), ErrNotSupported
	}
	return s.Internal.MarketAddBalance(p0, p1, p2, p3)
}

func (s *CurioChainRPCStub) MarketAddBalance(p0 context.Context, p1 address.Address, p2 address.Address, p3 types.BigInt) (cid.Cid, error) {
	return *new(cid.Cid), ErrNotSupported
}

func (s *CurioChainRPCStruct) MinerCreateBlock(p0 context.Context, p1 *api.BlockTemplate) (*types.BlockMsg, error) {
	if s.Internal.MinerCreateBlock == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.MinerCreateBlock(p0, p1)
}

func (s *CurioChainRPCStub) MinerCreateBlock(p0 context.Context, p1 *api.BlockTemplate) (*types.BlockMsg, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) MinerGetBaseInfo(p0 context.Context, p1 address.Address, p2 abi.ChainEpoch, p3 types.TipSetKey) (*api.MiningBaseInfo, error) {
	if s.Internal.MinerGetBaseInfo == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.MinerGetBaseInfo(p0, p1, p2, p3)
}

func (s *CurioChainRPCStub) MinerGetBaseInfo(p0 context.Context, p1 address.Address, p2 abi.ChainEpoch, p3 types.TipSetKey) (*api.MiningBaseInfo, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) MpoolGetNonce(p0 context.Context, p1 address.Address) (uint64, error) {
	if s.Internal.MpoolGetNonce == nil {
		return 0, ErrNotSupported
	}
	return s.Internal.MpoolGetNonce(p0, p1)
}

func (s *CurioChainRPCStub) MpoolGetNonce(p0 context.Context, p1 address.Address) (uint64, error) {
	return 0, ErrNotSupported
}

func (s *CurioChainRPCStruct) MpoolPush(p0 context.Context, p1 *types.SignedMessage) (cid.Cid, error) {
	if s.Internal.MpoolPush == nil {
		return *new(cid.Cid), ErrNotSupported
	}
	return s.Internal.MpoolPush(p0, p1)
}

func (s *CurioChainRPCStub) MpoolPush(p0 context.Context, p1 *types.SignedMessage) (cid.Cid, error) {
	return *new(cid.Cid), ErrNotSupported
}

func (s *CurioChainRPCStruct) MpoolPushMessage(p0 context.Context, p1 *types.Message, p2 *api.MessageSendSpec) (*types.SignedMessage, error) {
	if s.Internal.MpoolPushMessage == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.MpoolPushMessage(p0, p1, p2)
}

func (s *CurioChainRPCStub) MpoolPushMessage(p0 context.Context, p1 *types.Message, p2 *api.MessageSendSpec) (*types.SignedMessage, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) MpoolSelect(p0 context.Context, p1 types.TipSetKey, p2 float64) ([]*types.SignedMessage, error) {
	if s.Internal.MpoolSelect == nil {
		return *new([]*types.SignedMessage), ErrNotSupported
	}
	return s.Internal.MpoolSelect(p0, p1, p2)
}

func (s *CurioChainRPCStub) MpoolSelect(p0 context.Context, p1 types.TipSetKey, p2 float64) ([]*types.SignedMessage, error) {
	return *new([]*types.SignedMessage), ErrNotSupported
}

func (s *CurioChainRPCStruct) Session(p0 context.Context) (uuid.UUID, error) {
	if s.Internal.Session == nil {
		return *new(uuid.UUID), ErrNotSupported
	}
	return s.Internal.Session(p0)
}

func (s *CurioChainRPCStub) Session(p0 context.Context) (uuid.UUID, error) {
	return *new(uuid.UUID), ErrNotSupported
}

func (s *CurioChainRPCStruct) Shutdown(p0 context.Context) error {
	if s.Internal.Shutdown == nil {
		return ErrNotSupported
	}
	return s.Internal.Shutdown(p0)
}

func (s *CurioChainRPCStub) Shutdown(p0 context.Context) error {
	return ErrNotSupported
}

func (s *CurioChainRPCStruct) StateAccountKey(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (address.Address, error) {
	if s.Internal.StateAccountKey == nil {
		return *new(address.Address), ErrNotSupported
	}
	return s.Internal.StateAccountKey(p0, p1, p2)
}

func (s *CurioChainRPCStub) StateAccountKey(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (address.Address, error) {
	return *new(address.Address), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateCall(p0 context.Context, p1 *types.Message, p2 types.TipSetKey) (*api.InvocResult, error) {
	if s.Internal.StateCall == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateCall(p0, p1, p2)
}

func (s *CurioChainRPCStub) StateCall(p0 context.Context, p1 *types.Message, p2 types.TipSetKey) (*api.InvocResult, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) StateCirculatingSupply(p0 context.Context, p1 types.TipSetKey) (big.Int, error) {
	if s.Internal.StateCirculatingSupply == nil {
		return *new(big.Int), ErrNotSupported
	}
	return s.Internal.StateCirculatingSupply(p0, p1)
}

func (s *CurioChainRPCStub) StateCirculatingSupply(p0 context.Context, p1 types.TipSetKey) (big.Int, error) {
	return *new(big.Int), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateDealProviderCollateralBounds(p0 context.Context, p1 abi.PaddedPieceSize, p2 bool, p3 types.TipSetKey) (api.DealCollateralBounds, error) {
	if s.Internal.StateDealProviderCollateralBounds == nil {
		return *new(api.DealCollateralBounds), ErrNotSupported
	}
	return s.Internal.StateDealProviderCollateralBounds(p0, p1, p2, p3)
}

func (s *CurioChainRPCStub) StateDealProviderCollateralBounds(p0 context.Context, p1 abi.PaddedPieceSize, p2 bool, p3 types.TipSetKey) (api.DealCollateralBounds, error) {
	return *new(api.DealCollateralBounds), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateGetActor(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*types.Actor, error) {
	if s.Internal.StateGetActor == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateGetActor(p0, p1, p2)
}

func (s *CurioChainRPCStub) StateGetActor(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*types.Actor, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) StateGetAllocation(p0 context.Context, p1 address.Address, p2 verifregtypes.AllocationId, p3 types.TipSetKey) (*verifregtypes.Allocation, error) {
	if s.Internal.StateGetAllocation == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateGetAllocation(p0, p1, p2, p3)
}

func (s *CurioChainRPCStub) StateGetAllocation(p0 context.Context, p1 address.Address, p2 verifregtypes.AllocationId, p3 types.TipSetKey) (*verifregtypes.Allocation, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) StateGetAllocationForPendingDeal(p0 context.Context, p1 abi.DealID, p2 types.TipSetKey) (*verifregtypes.Allocation, error) {
	if s.Internal.StateGetAllocationForPendingDeal == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateGetAllocationForPendingDeal(p0, p1, p2)
}

func (s *CurioChainRPCStub) StateGetAllocationForPendingDeal(p0 context.Context, p1 abi.DealID, p2 types.TipSetKey) (*verifregtypes.Allocation, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) StateGetAllocationIdForPendingDeal(p0 context.Context, p1 abi.DealID, p2 types.TipSetKey) (verifregtypes.AllocationId, error) {
	if s.Internal.StateGetAllocationIdForPendingDeal == nil {
		return *new(verifregtypes.AllocationId), ErrNotSupported
	}
	return s.Internal.StateGetAllocationIdForPendingDeal(p0, p1, p2)
}

func (s *CurioChainRPCStub) StateGetAllocationIdForPendingDeal(p0 context.Context, p1 abi.DealID, p2 types.TipSetKey) (verifregtypes.AllocationId, error) {
	return *new(verifregtypes.AllocationId), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateGetBeaconEntry(p0 context.Context, p1 abi.ChainEpoch) (*types.BeaconEntry, error) {
	if s.Internal.StateGetBeaconEntry == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateGetBeaconEntry(p0, p1)
}

func (s *CurioChainRPCStub) StateGetBeaconEntry(p0 context.Context, p1 abi.ChainEpoch) (*types.BeaconEntry, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) StateGetRandomnessFromBeacon(p0 context.Context, p1 crypto.DomainSeparationTag, p2 abi.ChainEpoch, p3 []byte, p4 types.TipSetKey) (abi.Randomness, error) {
	if s.Internal.StateGetRandomnessFromBeacon == nil {
		return *new(abi.Randomness), ErrNotSupported
	}
	return s.Internal.StateGetRandomnessFromBeacon(p0, p1, p2, p3, p4)
}

func (s *CurioChainRPCStub) StateGetRandomnessFromBeacon(p0 context.Context, p1 crypto.DomainSeparationTag, p2 abi.ChainEpoch, p3 []byte, p4 types.TipSetKey) (abi.Randomness, error) {
	return *new(abi.Randomness), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateGetRandomnessFromTickets(p0 context.Context, p1 crypto.DomainSeparationTag, p2 abi.ChainEpoch, p3 []byte, p4 types.TipSetKey) (abi.Randomness, error) {
	if s.Internal.StateGetRandomnessFromTickets == nil {
		return *new(abi.Randomness), ErrNotSupported
	}
	return s.Internal.StateGetRandomnessFromTickets(p0, p1, p2, p3, p4)
}

func (s *CurioChainRPCStub) StateGetRandomnessFromTickets(p0 context.Context, p1 crypto.DomainSeparationTag, p2 abi.ChainEpoch, p3 []byte, p4 types.TipSetKey) (abi.Randomness, error) {
	return *new(abi.Randomness), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateListMessages(p0 context.Context, p1 *api.MessageMatch, p2 types.TipSetKey, p3 abi.ChainEpoch) ([]cid.Cid, error) {
	if s.Internal.StateListMessages == nil {
		return *new([]cid.Cid), ErrNotSupported
	}
	return s.Internal.StateListMessages(p0, p1, p2, p3)
}

func (s *CurioChainRPCStub) StateListMessages(p0 context.Context, p1 *api.MessageMatch, p2 types.TipSetKey, p3 abi.ChainEpoch) ([]cid.Cid, error) {
	return *new([]cid.Cid), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateListMiners(p0 context.Context, p1 types.TipSetKey) ([]address.Address, error) {
	if s.Internal.StateListMiners == nil {
		return *new([]address.Address), ErrNotSupported
	}
	return s.Internal.StateListMiners(p0, p1)
}

func (s *CurioChainRPCStub) StateListMiners(p0 context.Context, p1 types.TipSetKey) ([]address.Address, error) {
	return *new([]address.Address), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateLookupID(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (address.Address, error) {
	if s.Internal.StateLookupID == nil {
		return *new(address.Address), ErrNotSupported
	}
	return s.Internal.StateLookupID(p0, p1, p2)
}

func (s *CurioChainRPCStub) StateLookupID(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (address.Address, error) {
	return *new(address.Address), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateMarketBalance(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (api.MarketBalance, error) {
	if s.Internal.StateMarketBalance == nil {
		return *new(api.MarketBalance), ErrNotSupported
	}
	return s.Internal.StateMarketBalance(p0, p1, p2)
}

func (s *CurioChainRPCStub) StateMarketBalance(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (api.MarketBalance, error) {
	return *new(api.MarketBalance), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateMarketStorageDeal(p0 context.Context, p1 abi.DealID, p2 types.TipSetKey) (*api.MarketDeal, error) {
	if s.Internal.StateMarketStorageDeal == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateMarketStorageDeal(p0, p1, p2)
}

func (s *CurioChainRPCStub) StateMarketStorageDeal(p0 context.Context, p1 abi.DealID, p2 types.TipSetKey) (*api.MarketDeal, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) StateMinerActiveSectors(p0 context.Context, p1 address.Address, p2 types.TipSetKey) ([]*miner.SectorOnChainInfo, error) {
	if s.Internal.StateMinerActiveSectors == nil {
		return *new([]*miner.SectorOnChainInfo), ErrNotSupported
	}
	return s.Internal.StateMinerActiveSectors(p0, p1, p2)
}

func (s *CurioChainRPCStub) StateMinerActiveSectors(p0 context.Context, p1 address.Address, p2 types.TipSetKey) ([]*miner.SectorOnChainInfo, error) {
	return *new([]*miner.SectorOnChainInfo), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateMinerAllocated(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*bitfield.BitField, error) {
	if s.Internal.StateMinerAllocated == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateMinerAllocated(p0, p1, p2)
}

func (s *CurioChainRPCStub) StateMinerAllocated(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*bitfield.BitField, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) StateMinerAvailableBalance(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (types.BigInt, error) {
	if s.Internal.StateMinerAvailableBalance == nil {
		return *new(types.BigInt), ErrNotSupported
	}
	return s.Internal.StateMinerAvailableBalance(p0, p1, p2)
}

func (s *CurioChainRPCStub) StateMinerAvailableBalance(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (types.BigInt, error) {
	return *new(types.BigInt), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateMinerCreationDeposit(p0 context.Context, p1 types.TipSetKey) (types.BigInt, error) {
	if s.Internal.StateMinerCreationDeposit == nil {
		return *new(types.BigInt), ErrNotSupported
	}
	return s.Internal.StateMinerCreationDeposit(p0, p1)
}

func (s *CurioChainRPCStub) StateMinerCreationDeposit(p0 context.Context, p1 types.TipSetKey) (types.BigInt, error) {
	return *new(types.BigInt), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateMinerDeadlines(p0 context.Context, p1 address.Address, p2 types.TipSetKey) ([]api.Deadline, error) {
	if s.Internal.StateMinerDeadlines == nil {
		return *new([]api.Deadline), ErrNotSupported
	}
	return s.Internal.StateMinerDeadlines(p0, p1, p2)
}

func (s *CurioChainRPCStub) StateMinerDeadlines(p0 context.Context, p1 address.Address, p2 types.TipSetKey) ([]api.Deadline, error) {
	return *new([]api.Deadline), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateMinerFaults(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (bitfield.BitField, error) {
	if s.Internal.StateMinerFaults == nil {
		return *new(bitfield.BitField), ErrNotSupported
	}
	return s.Internal.StateMinerFaults(p0, p1, p2)
}

func (s *CurioChainRPCStub) StateMinerFaults(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (bitfield.BitField, error) {
	return *new(bitfield.BitField), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateMinerInfo(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (api.MinerInfo, error) {
	if s.Internal.StateMinerInfo == nil {
		return *new(api.MinerInfo), ErrNotSupported
	}
	return s.Internal.StateMinerInfo(p0, p1, p2)
}

func (s *CurioChainRPCStub) StateMinerInfo(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (api.MinerInfo, error) {
	return *new(api.MinerInfo), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateMinerInitialPledgeForSector(p0 context.Context, p1 abi.ChainEpoch, p2 abi.SectorSize, p3 uint64, p4 types.TipSetKey) (types.BigInt, error) {
	if s.Internal.StateMinerInitialPledgeForSector == nil {
		return *new(types.BigInt), ErrNotSupported
	}
	return s.Internal.StateMinerInitialPledgeForSector(p0, p1, p2, p3, p4)
}

func (s *CurioChainRPCStub) StateMinerInitialPledgeForSector(p0 context.Context, p1 abi.ChainEpoch, p2 abi.SectorSize, p3 uint64, p4 types.TipSetKey) (types.BigInt, error) {
	return *new(types.BigInt), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateMinerPartitions(p0 context.Context, p1 address.Address, p2 uint64, p3 types.TipSetKey) ([]api.Partition, error) {
	if s.Internal.StateMinerPartitions == nil {
		return *new([]api.Partition), ErrNotSupported
	}
	return s.Internal.StateMinerPartitions(p0, p1, p2, p3)
}

func (s *CurioChainRPCStub) StateMinerPartitions(p0 context.Context, p1 address.Address, p2 uint64, p3 types.TipSetKey) ([]api.Partition, error) {
	return *new([]api.Partition), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateMinerPower(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*api.MinerPower, error) {
	if s.Internal.StateMinerPower == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateMinerPower(p0, p1, p2)
}

func (s *CurioChainRPCStub) StateMinerPower(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*api.MinerPower, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) StateMinerPreCommitDepositForPower(p0 context.Context, p1 address.Address, p2 miner.SectorPreCommitInfo, p3 types.TipSetKey) (big.Int, error) {
	if s.Internal.StateMinerPreCommitDepositForPower == nil {
		return *new(big.Int), ErrNotSupported
	}
	return s.Internal.StateMinerPreCommitDepositForPower(p0, p1, p2, p3)
}

func (s *CurioChainRPCStub) StateMinerPreCommitDepositForPower(p0 context.Context, p1 address.Address, p2 miner.SectorPreCommitInfo, p3 types.TipSetKey) (big.Int, error) {
	return *new(big.Int), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateMinerProvingDeadline(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*dline.Info, error) {
	if s.Internal.StateMinerProvingDeadline == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateMinerProvingDeadline(p0, p1, p2)
}

func (s *CurioChainRPCStub) StateMinerProvingDeadline(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*dline.Info, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) StateMinerRecoveries(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (bitfield.BitField, error) {
	if s.Internal.StateMinerRecoveries == nil {
		return *new(bitfield.BitField), ErrNotSupported
	}
	return s.Internal.StateMinerRecoveries(p0, p1, p2)
}

func (s *CurioChainRPCStub) StateMinerRecoveries(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (bitfield.BitField, error) {
	return *new(bitfield.BitField), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateMinerSectorCount(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (api.MinerSectors, error) {
	if s.Internal.StateMinerSectorCount == nil {
		return *new(api.MinerSectors), ErrNotSupported
	}
	return s.Internal.StateMinerSectorCount(p0, p1, p2)
}

func (s *CurioChainRPCStub) StateMinerSectorCount(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (api.MinerSectors, error) {
	return *new(api.MinerSectors), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateMinerSectors(p0 context.Context, p1 address.Address, p2 *bitfield.BitField, p3 types.TipSetKey) ([]*miner.SectorOnChainInfo, error) {
	if s.Internal.StateMinerSectors == nil {
		return *new([]*miner.SectorOnChainInfo), ErrNotSupported
	}
	return s.Internal.StateMinerSectors(p0, p1, p2, p3)
}

func (s *CurioChainRPCStub) StateMinerSectors(p0 context.Context, p1 address.Address, p2 *bitfield.BitField, p3 types.TipSetKey) ([]*miner.SectorOnChainInfo, error) {
	return *new([]*miner.SectorOnChainInfo), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateNetworkName(p0 context.Context) (dtypes.NetworkName, error) {
	if s.Internal.StateNetworkName == nil {
		return *new(dtypes.NetworkName), ErrNotSupported
	}
	return s.Internal.StateNetworkName(p0)
}

func (s *CurioChainRPCStub) StateNetworkName(p0 context.Context) (dtypes.NetworkName, error) {
	return *new(dtypes.NetworkName), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateNetworkVersion(p0 context.Context, p1 types.TipSetKey) (network.Version, error) {
	if s.Internal.StateNetworkVersion == nil {
		return *new(network.Version), ErrNotSupported
	}
	return s.Internal.StateNetworkVersion(p0, p1)
}

func (s *CurioChainRPCStub) StateNetworkVersion(p0 context.Context, p1 types.TipSetKey) (network.Version, error) {
	return *new(network.Version), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateReadState(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*api.ActorState, error) {
	if s.Internal.StateReadState == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateReadState(p0, p1, p2)
}

func (s *CurioChainRPCStub) StateReadState(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*api.ActorState, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) StateSearchMsg(p0 context.Context, p1 types.TipSetKey, p2 cid.Cid, p3 abi.ChainEpoch, p4 bool) (*api.MsgLookup, error) {
	if s.Internal.StateSearchMsg == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateSearchMsg(p0, p1, p2, p3, p4)
}

func (s *CurioChainRPCStub) StateSearchMsg(p0 context.Context, p1 types.TipSetKey, p2 cid.Cid, p3 abi.ChainEpoch, p4 bool) (*api.MsgLookup, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) StateSectorGetInfo(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*miner.SectorOnChainInfo, error) {
	if s.Internal.StateSectorGetInfo == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateSectorGetInfo(p0, p1, p2, p3)
}

func (s *CurioChainRPCStub) StateSectorGetInfo(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*miner.SectorOnChainInfo, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) StateSectorPartition(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*miner.SectorLocation, error) {
	if s.Internal.StateSectorPartition == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateSectorPartition(p0, p1, p2, p3)
}

func (s *CurioChainRPCStub) StateSectorPartition(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*miner.SectorLocation, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) StateSectorPreCommitInfo(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*miner.SectorPreCommitOnChainInfo, error) {
	if s.Internal.StateSectorPreCommitInfo == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateSectorPreCommitInfo(p0, p1, p2, p3)
}

func (s *CurioChainRPCStub) StateSectorPreCommitInfo(p0 context.Context, p1 address.Address, p2 abi.SectorNumber, p3 types.TipSetKey) (*miner.SectorPreCommitOnChainInfo, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) StateVMCirculatingSupplyInternal(p0 context.Context, p1 types.TipSetKey) (api.CirculatingSupply, error) {
	if s.Internal.StateVMCirculatingSupplyInternal == nil {
		return *new(api.CirculatingSupply), ErrNotSupported
	}
	return s.Internal.StateVMCirculatingSupplyInternal(p0, p1)
}

func (s *CurioChainRPCStub) StateVMCirculatingSupplyInternal(p0 context.Context, p1 types.TipSetKey) (api.CirculatingSupply, error) {
	return *new(api.CirculatingSupply), ErrNotSupported
}

func (s *CurioChainRPCStruct) StateVerifiedClientStatus(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*abi.StoragePower, error) {
	if s.Internal.StateVerifiedClientStatus == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateVerifiedClientStatus(p0, p1, p2)
}

func (s *CurioChainRPCStub) StateVerifiedClientStatus(p0 context.Context, p1 address.Address, p2 types.TipSetKey) (*abi.StoragePower, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) StateWaitMsg(p0 context.Context, p1 cid.Cid, p2 uint64, p3 abi.ChainEpoch, p4 bool) (*api.MsgLookup, error) {
	if s.Internal.StateWaitMsg == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.StateWaitMsg(p0, p1, p2, p3, p4)
}

func (s *CurioChainRPCStub) StateWaitMsg(p0 context.Context, p1 cid.Cid, p2 uint64, p3 abi.ChainEpoch, p4 bool) (*api.MsgLookup, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) SyncSubmitBlock(p0 context.Context, p1 *types.BlockMsg) error {
	if s.Internal.SyncSubmitBlock == nil {
		return ErrNotSupported
	}
	return s.Internal.SyncSubmitBlock(p0, p1)
}

func (s *CurioChainRPCStub) SyncSubmitBlock(p0 context.Context, p1 *types.BlockMsg) error {
	return ErrNotSupported
}

func (s *CurioChainRPCStruct) Version(p0 context.Context) (api.APIVersion, error) {
	if s.Internal.Version == nil {
		return *new(api.APIVersion), ErrNotSupported
	}
	return s.Internal.Version(p0)
}

func (s *CurioChainRPCStub) Version(p0 context.Context) (api.APIVersion, error) {
	return *new(api.APIVersion), ErrNotSupported
}

func (s *CurioChainRPCStruct) WalletBalance(p0 context.Context, p1 address.Address) (big.Int, error) {
	if s.Internal.WalletBalance == nil {
		return *new(big.Int), ErrNotSupported
	}
	return s.Internal.WalletBalance(p0, p1)
}

func (s *CurioChainRPCStub) WalletBalance(p0 context.Context, p1 address.Address) (big.Int, error) {
	return *new(big.Int), ErrNotSupported
}

func (s *CurioChainRPCStruct) WalletHas(p0 context.Context, p1 address.Address) (bool, error) {
	if s.Internal.WalletHas == nil {
		return false, ErrNotSupported
	}
	return s.Internal.WalletHas(p0, p1)
}

func (s *CurioChainRPCStub) WalletHas(p0 context.Context, p1 address.Address) (bool, error) {
	return false, ErrNotSupported
}

func (s *CurioChainRPCStruct) WalletSign(p0 context.Context, p1 address.Address, p2 []byte) (*crypto.Signature, error) {
	if s.Internal.WalletSign == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.WalletSign(p0, p1, p2)
}

func (s *CurioChainRPCStub) WalletSign(p0 context.Context, p1 address.Address, p2 []byte) (*crypto.Signature, error) {
	return nil, ErrNotSupported
}

func (s *CurioChainRPCStruct) WalletSignMessage(p0 context.Context, p1 address.Address, p2 *types.Message) (*types.SignedMessage, error) {
	if s.Internal.WalletSignMessage == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.WalletSignMessage(p0, p1, p2)
}

func (s *CurioChainRPCStub) WalletSignMessage(p0 context.Context, p1 address.Address, p2 *types.Message) (*types.SignedMessage, error) {
	return nil, ErrNotSupported
}

func (s *EthClientInterfaceStruct) BalanceAt(p0 context.Context, p1 common.Address, p2 *mathbig.Int) (*mathbig.Int, error) {
	if s.Internal.BalanceAt == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.BalanceAt(p0, p1, p2)
}

func (s *EthClientInterfaceStub) BalanceAt(p0 context.Context, p1 common.Address, p2 *mathbig.Int) (*mathbig.Int, error) {
	return nil, ErrNotSupported
}

func (s *EthClientInterfaceStruct) BalanceAtHash(p0 context.Context, p1 common.Address, p2 common.Hash) (*mathbig.Int, error) {
	if s.Internal.BalanceAtHash == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.BalanceAtHash(p0, p1, p2)
}

func (s *EthClientInterfaceStub) BalanceAtHash(p0 context.Context, p1 common.Address, p2 common.Hash) (*mathbig.Int, error) {
	return nil, ErrNotSupported
}

func (s *EthClientInterfaceStruct) BlockByHash(p0 context.Context, p1 common.Hash) (*ethtypes.Block, error) {
	if s.Internal.BlockByHash == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.BlockByHash(p0, p1)
}

func (s *EthClientInterfaceStub) BlockByHash(p0 context.Context, p1 common.Hash) (*ethtypes.Block, error) {
	return nil, ErrNotSupported
}

func (s *EthClientInterfaceStruct) BlockByNumber(p0 context.Context, p1 *mathbig.Int) (*ethtypes.Block, error) {
	if s.Internal.BlockByNumber == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.BlockByNumber(p0, p1)
}

func (s *EthClientInterfaceStub) BlockByNumber(p0 context.Context, p1 *mathbig.Int) (*ethtypes.Block, error) {
	return nil, ErrNotSupported
}

func (s *EthClientInterfaceStruct) BlockNumber(p0 context.Context) (uint64, error) {
	if s.Internal.BlockNumber == nil {
		return 0, ErrNotSupported
	}
	return s.Internal.BlockNumber(p0)
}

func (s *EthClientInterfaceStub) BlockNumber(p0 context.Context) (uint64, error) {
	return 0, ErrNotSupported
}

func (s *EthClientInterfaceStruct) BlockReceipts(p0 context.Context, p1 erpc.BlockNumberOrHash) ([]*ethtypes.Receipt, error) {
	if s.Internal.BlockReceipts == nil {
		return *new([]*ethtypes.Receipt), ErrNotSupported
	}
	return s.Internal.BlockReceipts(p0, p1)
}

func (s *EthClientInterfaceStub) BlockReceipts(p0 context.Context, p1 erpc.BlockNumberOrHash) ([]*ethtypes.Receipt, error) {
	return *new([]*ethtypes.Receipt), ErrNotSupported
}

func (s *EthClientInterfaceStruct) CallContract(p0 context.Context, p1 ethereum.CallMsg, p2 *mathbig.Int) ([]byte, error) {
	if s.Internal.CallContract == nil {
		return *new([]byte), ErrNotSupported
	}
	return s.Internal.CallContract(p0, p1, p2)
}

func (s *EthClientInterfaceStub) CallContract(p0 context.Context, p1 ethereum.CallMsg, p2 *mathbig.Int) ([]byte, error) {
	return *new([]byte), ErrNotSupported
}

func (s *EthClientInterfaceStruct) CallContractAtHash(p0 context.Context, p1 ethereum.CallMsg, p2 common.Hash) ([]byte, error) {
	if s.Internal.CallContractAtHash == nil {
		return *new([]byte), ErrNotSupported
	}
	return s.Internal.CallContractAtHash(p0, p1, p2)
}

func (s *EthClientInterfaceStub) CallContractAtHash(p0 context.Context, p1 ethereum.CallMsg, p2 common.Hash) ([]byte, error) {
	return *new([]byte), ErrNotSupported
}

func (s *EthClientInterfaceStruct) ChainID(p0 context.Context) (*mathbig.Int, error) {
	if s.Internal.ChainID == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.ChainID(p0)
}

func (s *EthClientInterfaceStub) ChainID(p0 context.Context) (*mathbig.Int, error) {
	return nil, ErrNotSupported
}

func (s *EthClientInterfaceStruct) CodeAt(p0 context.Context, p1 common.Address, p2 *mathbig.Int) ([]byte, error) {
	if s.Internal.CodeAt == nil {
		return *new([]byte), ErrNotSupported
	}
	return s.Internal.CodeAt(p0, p1, p2)
}

func (s *EthClientInterfaceStub) CodeAt(p0 context.Context, p1 common.Address, p2 *mathbig.Int) ([]byte, error) {
	return *new([]byte), ErrNotSupported
}

func (s *EthClientInterfaceStruct) CodeAtHash(p0 context.Context, p1 common.Address, p2 common.Hash) ([]byte, error) {
	if s.Internal.CodeAtHash == nil {
		return *new([]byte), ErrNotSupported
	}
	return s.Internal.CodeAtHash(p0, p1, p2)
}

func (s *EthClientInterfaceStub) CodeAtHash(p0 context.Context, p1 common.Address, p2 common.Hash) ([]byte, error) {
	return *new([]byte), ErrNotSupported
}

func (s *EthClientInterfaceStruct) EstimateGas(p0 context.Context, p1 ethereum.CallMsg) (uint64, error) {
	if s.Internal.EstimateGas == nil {
		return 0, ErrNotSupported
	}
	return s.Internal.EstimateGas(p0, p1)
}

func (s *EthClientInterfaceStub) EstimateGas(p0 context.Context, p1 ethereum.CallMsg) (uint64, error) {
	return 0, ErrNotSupported
}

func (s *EthClientInterfaceStruct) FeeHistory(p0 context.Context, p1 uint64, p2 *mathbig.Int, p3 []float64) (*ethereum.FeeHistory, error) {
	if s.Internal.FeeHistory == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.FeeHistory(p0, p1, p2, p3)
}

func (s *EthClientInterfaceStub) FeeHistory(p0 context.Context, p1 uint64, p2 *mathbig.Int, p3 []float64) (*ethereum.FeeHistory, error) {
	return nil, ErrNotSupported
}

func (s *EthClientInterfaceStruct) FilterLogs(p0 context.Context, p1 ethereum.FilterQuery) ([]ethtypes.Log, error) {
	if s.Internal.FilterLogs == nil {
		return *new([]ethtypes.Log), ErrNotSupported
	}
	return s.Internal.FilterLogs(p0, p1)
}

func (s *EthClientInterfaceStub) FilterLogs(p0 context.Context, p1 ethereum.FilterQuery) ([]ethtypes.Log, error) {
	return *new([]ethtypes.Log), ErrNotSupported
}

func (s *EthClientInterfaceStruct) HeaderByHash(p0 context.Context, p1 common.Hash) (*ethtypes.Header, error) {
	if s.Internal.HeaderByHash == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.HeaderByHash(p0, p1)
}

func (s *EthClientInterfaceStub) HeaderByHash(p0 context.Context, p1 common.Hash) (*ethtypes.Header, error) {
	return nil, ErrNotSupported
}

func (s *EthClientInterfaceStruct) HeaderByNumber(p0 context.Context, p1 *mathbig.Int) (*ethtypes.Header, error) {
	if s.Internal.HeaderByNumber == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.HeaderByNumber(p0, p1)
}

func (s *EthClientInterfaceStub) HeaderByNumber(p0 context.Context, p1 *mathbig.Int) (*ethtypes.Header, error) {
	return nil, ErrNotSupported
}

func (s *EthClientInterfaceStruct) NetworkID(p0 context.Context) (*mathbig.Int, error) {
	if s.Internal.NetworkID == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.NetworkID(p0)
}

func (s *EthClientInterfaceStub) NetworkID(p0 context.Context) (*mathbig.Int, error) {
	return nil, ErrNotSupported
}

func (s *EthClientInterfaceStruct) NonceAt(p0 context.Context, p1 common.Address, p2 *mathbig.Int) (uint64, error) {
	if s.Internal.NonceAt == nil {
		return 0, ErrNotSupported
	}
	return s.Internal.NonceAt(p0, p1, p2)
}

func (s *EthClientInterfaceStub) NonceAt(p0 context.Context, p1 common.Address, p2 *mathbig.Int) (uint64, error) {
	return 0, ErrNotSupported
}

func (s *EthClientInterfaceStruct) NonceAtHash(p0 context.Context, p1 common.Address, p2 common.Hash) (uint64, error) {
	if s.Internal.NonceAtHash == nil {
		return 0, ErrNotSupported
	}
	return s.Internal.NonceAtHash(p0, p1, p2)
}

func (s *EthClientInterfaceStub) NonceAtHash(p0 context.Context, p1 common.Address, p2 common.Hash) (uint64, error) {
	return 0, ErrNotSupported
}

func (s *EthClientInterfaceStruct) PeerCount(p0 context.Context) (uint64, error) {
	if s.Internal.PeerCount == nil {
		return 0, ErrNotSupported
	}
	return s.Internal.PeerCount(p0)
}

func (s *EthClientInterfaceStub) PeerCount(p0 context.Context) (uint64, error) {
	return 0, ErrNotSupported
}

func (s *EthClientInterfaceStruct) PendingBalanceAt(p0 context.Context, p1 common.Address) (*mathbig.Int, error) {
	if s.Internal.PendingBalanceAt == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.PendingBalanceAt(p0, p1)
}

func (s *EthClientInterfaceStub) PendingBalanceAt(p0 context.Context, p1 common.Address) (*mathbig.Int, error) {
	return nil, ErrNotSupported
}

func (s *EthClientInterfaceStruct) PendingCallContract(p0 context.Context, p1 ethereum.CallMsg) ([]byte, error) {
	if s.Internal.PendingCallContract == nil {
		return *new([]byte), ErrNotSupported
	}
	return s.Internal.PendingCallContract(p0, p1)
}

func (s *EthClientInterfaceStub) PendingCallContract(p0 context.Context, p1 ethereum.CallMsg) ([]byte, error) {
	return *new([]byte), ErrNotSupported
}

func (s *EthClientInterfaceStruct) PendingCodeAt(p0 context.Context, p1 common.Address) ([]byte, error) {
	if s.Internal.PendingCodeAt == nil {
		return *new([]byte), ErrNotSupported
	}
	return s.Internal.PendingCodeAt(p0, p1)
}

func (s *EthClientInterfaceStub) PendingCodeAt(p0 context.Context, p1 common.Address) ([]byte, error) {
	return *new([]byte), ErrNotSupported
}

func (s *EthClientInterfaceStruct) PendingNonceAt(p0 context.Context, p1 common.Address) (uint64, error) {
	if s.Internal.PendingNonceAt == nil {
		return 0, ErrNotSupported
	}
	return s.Internal.PendingNonceAt(p0, p1)
}

func (s *EthClientInterfaceStub) PendingNonceAt(p0 context.Context, p1 common.Address) (uint64, error) {
	return 0, ErrNotSupported
}

func (s *EthClientInterfaceStruct) PendingStorageAt(p0 context.Context, p1 common.Address, p2 common.Hash) ([]byte, error) {
	if s.Internal.PendingStorageAt == nil {
		return *new([]byte), ErrNotSupported
	}
	return s.Internal.PendingStorageAt(p0, p1, p2)
}

func (s *EthClientInterfaceStub) PendingStorageAt(p0 context.Context, p1 common.Address, p2 common.Hash) ([]byte, error) {
	return *new([]byte), ErrNotSupported
}

func (s *EthClientInterfaceStruct) PendingTransactionCount(p0 context.Context) (uint, error) {
	if s.Internal.PendingTransactionCount == nil {
		return 0, ErrNotSupported
	}
	return s.Internal.PendingTransactionCount(p0)
}

func (s *EthClientInterfaceStub) PendingTransactionCount(p0 context.Context) (uint, error) {
	return 0, ErrNotSupported
}

func (s *EthClientInterfaceStruct) SendTransaction(p0 context.Context, p1 *ethtypes.Transaction) error {
	if s.Internal.SendTransaction == nil {
		return ErrNotSupported
	}
	return s.Internal.SendTransaction(p0, p1)
}

func (s *EthClientInterfaceStub) SendTransaction(p0 context.Context, p1 *ethtypes.Transaction) error {
	return ErrNotSupported
}

func (s *EthClientInterfaceStruct) StorageAt(p0 context.Context, p1 common.Address, p2 common.Hash, p3 *mathbig.Int) ([]byte, error) {
	if s.Internal.StorageAt == nil {
		return *new([]byte), ErrNotSupported
	}
	return s.Internal.StorageAt(p0, p1, p2, p3)
}

func (s *EthClientInterfaceStub) StorageAt(p0 context.Context, p1 common.Address, p2 common.Hash, p3 *mathbig.Int) ([]byte, error) {
	return *new([]byte), ErrNotSupported
}

func (s *EthClientInterfaceStruct) StorageAtHash(p0 context.Context, p1 common.Address, p2 common.Hash, p3 common.Hash) ([]byte, error) {
	if s.Internal.StorageAtHash == nil {
		return *new([]byte), ErrNotSupported
	}
	return s.Internal.StorageAtHash(p0, p1, p2, p3)
}

func (s *EthClientInterfaceStub) StorageAtHash(p0 context.Context, p1 common.Address, p2 common.Hash, p3 common.Hash) ([]byte, error) {
	return *new([]byte), ErrNotSupported
}

func (s *EthClientInterfaceStruct) SubscribeFilterLogs(p0 context.Context, p1 ethereum.FilterQuery, p2 chan<- ethtypes.Log) (ethereum.Subscription, error) {
	if s.Internal.SubscribeFilterLogs == nil {
		return *new(ethereum.Subscription), ErrNotSupported
	}
	return s.Internal.SubscribeFilterLogs(p0, p1, p2)
}

func (s *EthClientInterfaceStub) SubscribeFilterLogs(p0 context.Context, p1 ethereum.FilterQuery, p2 chan<- ethtypes.Log) (ethereum.Subscription, error) {
	return *new(ethereum.Subscription), ErrNotSupported
}

func (s *EthClientInterfaceStruct) SubscribeNewHead(p0 context.Context, p1 chan<- *ethtypes.Header) (ethereum.Subscription, error) {
	if s.Internal.SubscribeNewHead == nil {
		return *new(ethereum.Subscription), ErrNotSupported
	}
	return s.Internal.SubscribeNewHead(p0, p1)
}

func (s *EthClientInterfaceStub) SubscribeNewHead(p0 context.Context, p1 chan<- *ethtypes.Header) (ethereum.Subscription, error) {
	return *new(ethereum.Subscription), ErrNotSupported
}

func (s *EthClientInterfaceStruct) SuggestGasPrice(p0 context.Context) (*mathbig.Int, error) {
	if s.Internal.SuggestGasPrice == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.SuggestGasPrice(p0)
}

func (s *EthClientInterfaceStub) SuggestGasPrice(p0 context.Context) (*mathbig.Int, error) {
	return nil, ErrNotSupported
}

func (s *EthClientInterfaceStruct) SuggestGasTipCap(p0 context.Context) (*mathbig.Int, error) {
	if s.Internal.SuggestGasTipCap == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.SuggestGasTipCap(p0)
}

func (s *EthClientInterfaceStub) SuggestGasTipCap(p0 context.Context) (*mathbig.Int, error) {
	return nil, ErrNotSupported
}

func (s *EthClientInterfaceStruct) SyncProgress(p0 context.Context) (*ethereum.SyncProgress, error) {
	if s.Internal.SyncProgress == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.SyncProgress(p0)
}

func (s *EthClientInterfaceStub) SyncProgress(p0 context.Context) (*ethereum.SyncProgress, error) {
	return nil, ErrNotSupported
}

func (s *EthClientInterfaceStruct) TransactionByHash(p0 context.Context, p1 common.Hash) (*ethtypes.Transaction, bool, error) {
	if s.Internal.TransactionByHash == nil {
		return nil, false, ErrNotSupported
	}
	return s.Internal.TransactionByHash(p0, p1)
}

func (s *EthClientInterfaceStub) TransactionByHash(p0 context.Context, p1 common.Hash) (*ethtypes.Transaction, bool, error) {
	return nil, false, ErrNotSupported
}

func (s *EthClientInterfaceStruct) TransactionCount(p0 context.Context, p1 common.Hash) (uint, error) {
	if s.Internal.TransactionCount == nil {
		return 0, ErrNotSupported
	}
	return s.Internal.TransactionCount(p0, p1)
}

func (s *EthClientInterfaceStub) TransactionCount(p0 context.Context, p1 common.Hash) (uint, error) {
	return 0, ErrNotSupported
}

func (s *EthClientInterfaceStruct) TransactionInBlock(p0 context.Context, p1 common.Hash, p2 uint) (*ethtypes.Transaction, error) {
	if s.Internal.TransactionInBlock == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.TransactionInBlock(p0, p1, p2)
}

func (s *EthClientInterfaceStub) TransactionInBlock(p0 context.Context, p1 common.Hash, p2 uint) (*ethtypes.Transaction, error) {
	return nil, ErrNotSupported
}

func (s *EthClientInterfaceStruct) TransactionReceipt(p0 context.Context, p1 common.Hash) (*ethtypes.Receipt, error) {
	if s.Internal.TransactionReceipt == nil {
		return nil, ErrNotSupported
	}
	return s.Internal.TransactionReceipt(p0, p1)
}

func (s *EthClientInterfaceStub) TransactionReceipt(p0 context.Context, p1 common.Hash) (*ethtypes.Receipt, error) {
	return nil, ErrNotSupported
}

func (s *EthClientInterfaceStruct) TransactionSender(p0 context.Context, p1 *ethtypes.Transaction, p2 common.Hash, p3 uint) (common.Address, error) {
	if s.Internal.TransactionSender == nil {
		return *new(common.Address), ErrNotSupported
	}
	return s.Internal.TransactionSender(p0, p1, p2, p3)
}

func (s *EthClientInterfaceStub) TransactionSender(p0 context.Context, p1 *ethtypes.Transaction, p2 common.Hash, p3 uint) (common.Address, error) {
	return *new(common.Address), ErrNotSupported
}

var _ Curio = new(CurioStruct)
var _ CurioChainRPC = new(CurioChainRPCStruct)
var _ EthClientInterface = new(EthClientInterfaceStruct)
