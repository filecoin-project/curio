// Code generated by MockGen. DO NOT EDIT.
// Source: interface.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	io "io"
	url "net/url"
	os "os"
	reflect "reflect"

	partialfile "github.com/filecoin-project/curio/lib/partialfile"
	storiface "github.com/filecoin-project/curio/lib/storiface"
	abi "github.com/filecoin-project/go-state-types/abi"
	fsutil "github.com/filecoin-project/lotus/storage/sealer/fsutil"
	gomock "github.com/golang/mock/gomock"
	uuid "github.com/google/uuid"
	cid "github.com/ipfs/go-cid"
)

// MockPartialFileHandler is a mock of PartialFileHandler interface.
type MockPartialFileHandler struct {
	ctrl     *gomock.Controller
	recorder *MockPartialFileHandlerMockRecorder
}

// MockPartialFileHandlerMockRecorder is the mock recorder for MockPartialFileHandler.
type MockPartialFileHandlerMockRecorder struct {
	mock *MockPartialFileHandler
}

// NewMockPartialFileHandler creates a new mock instance.
func NewMockPartialFileHandler(ctrl *gomock.Controller) *MockPartialFileHandler {
	mock := &MockPartialFileHandler{ctrl: ctrl}
	mock.recorder = &MockPartialFileHandlerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPartialFileHandler) EXPECT() *MockPartialFileHandlerMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockPartialFileHandler) Close(pf *partialfile.PartialFile) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close", pf)
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockPartialFileHandlerMockRecorder) Close(pf interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockPartialFileHandler)(nil).Close), pf)
}

// HasAllocated mocks base method.
func (m *MockPartialFileHandler) HasAllocated(pf *partialfile.PartialFile, offset storiface.UnpaddedByteIndex, size abi.UnpaddedPieceSize) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasAllocated", pf, offset, size)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HasAllocated indicates an expected call of HasAllocated.
func (mr *MockPartialFileHandlerMockRecorder) HasAllocated(pf, offset, size interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasAllocated", reflect.TypeOf((*MockPartialFileHandler)(nil).HasAllocated), pf, offset, size)
}

// OpenPartialFile mocks base method.
func (m *MockPartialFileHandler) OpenPartialFile(maxPieceSize abi.PaddedPieceSize, path string) (*partialfile.PartialFile, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OpenPartialFile", maxPieceSize, path)
	ret0, _ := ret[0].(*partialfile.PartialFile)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// OpenPartialFile indicates an expected call of OpenPartialFile.
func (mr *MockPartialFileHandlerMockRecorder) OpenPartialFile(maxPieceSize, path interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OpenPartialFile", reflect.TypeOf((*MockPartialFileHandler)(nil).OpenPartialFile), maxPieceSize, path)
}

// Reader mocks base method.
func (m *MockPartialFileHandler) Reader(pf *partialfile.PartialFile, offset storiface.PaddedByteIndex, size abi.PaddedPieceSize) (io.Reader, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Reader", pf, offset, size)
	ret0, _ := ret[0].(io.Reader)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Reader indicates an expected call of Reader.
func (mr *MockPartialFileHandlerMockRecorder) Reader(pf, offset, size interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Reader", reflect.TypeOf((*MockPartialFileHandler)(nil).Reader), pf, offset, size)
}

// MockStore is a mock of Store interface.
type MockStore struct {
	ctrl     *gomock.Controller
	recorder *MockStoreMockRecorder
}

// MockStoreMockRecorder is the mock recorder for MockStore.
type MockStoreMockRecorder struct {
	mock *MockStore
}

// NewMockStore creates a new mock instance.
func NewMockStore(ctrl *gomock.Controller) *MockStore {
	mock := &MockStore{ctrl: ctrl}
	mock.recorder = &MockStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStore) EXPECT() *MockStoreMockRecorder {
	return m.recorder
}

// AcquireSector mocks base method.
func (m *MockStore) AcquireSector(ctx context.Context, s storiface.SectorRef, existing, allocate storiface.SectorFileType, sealing storiface.PathType, op storiface.AcquireMode, opts ...storiface.AcquireOption) (storiface.SectorPaths, storiface.SectorPaths, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, s, existing, allocate, sealing, op}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AcquireSector", varargs...)
	ret0, _ := ret[0].(storiface.SectorPaths)
	ret1, _ := ret[1].(storiface.SectorPaths)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// AcquireSector indicates an expected call of AcquireSector.
func (mr *MockStoreMockRecorder) AcquireSector(ctx, s, existing, allocate, sealing, op interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, s, existing, allocate, sealing, op}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AcquireSector", reflect.TypeOf((*MockStore)(nil).AcquireSector), varargs...)
}

// FsStat mocks base method.
func (m *MockStore) FsStat(ctx context.Context, id storiface.ID) (fsutil.FsStat, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FsStat", ctx, id)
	ret0, _ := ret[0].(fsutil.FsStat)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FsStat indicates an expected call of FsStat.
func (mr *MockStoreMockRecorder) FsStat(ctx, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FsStat", reflect.TypeOf((*MockStore)(nil).FsStat), ctx, id)
}

// GeneratePoRepVanillaProof mocks base method.
func (m *MockStore) GeneratePoRepVanillaProof(ctx context.Context, sr storiface.SectorRef, sealed, unsealed cid.Cid, ticket abi.SealRandomness, seed abi.InteractiveSealRandomness) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GeneratePoRepVanillaProof", ctx, sr, sealed, unsealed, ticket, seed)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GeneratePoRepVanillaProof indicates an expected call of GeneratePoRepVanillaProof.
func (mr *MockStoreMockRecorder) GeneratePoRepVanillaProof(ctx, sr, sealed, unsealed, ticket, seed interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GeneratePoRepVanillaProof", reflect.TypeOf((*MockStore)(nil).GeneratePoRepVanillaProof), ctx, sr, sealed, unsealed, ticket, seed)
}

// GenerateSingleVanillaProof mocks base method.
func (m *MockStore) GenerateSingleVanillaProof(ctx context.Context, minerID abi.ActorID, si storiface.PostSectorChallenge, ppt abi.RegisteredPoStProof) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GenerateSingleVanillaProof", ctx, minerID, si, ppt)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GenerateSingleVanillaProof indicates an expected call of GenerateSingleVanillaProof.
func (mr *MockStoreMockRecorder) GenerateSingleVanillaProof(ctx, minerID, si, ppt interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateSingleVanillaProof", reflect.TypeOf((*MockStore)(nil).GenerateSingleVanillaProof), ctx, minerID, si, ppt)
}

// MoveStorage mocks base method.
func (m *MockStore) MoveStorage(ctx context.Context, s storiface.SectorRef, types storiface.SectorFileType, opts ...storiface.AcquireOption) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, s, types}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MoveStorage", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// MoveStorage indicates an expected call of MoveStorage.
func (mr *MockStoreMockRecorder) MoveStorage(ctx, s, types interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, s, types}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MoveStorage", reflect.TypeOf((*MockStore)(nil).MoveStorage), varargs...)
}

// ReadSnapVanillaProof mocks base method.
func (m *MockStore) ReadSnapVanillaProof(ctx context.Context, sr storiface.SectorRef) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadSnapVanillaProof", ctx, sr)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadSnapVanillaProof indicates an expected call of ReadSnapVanillaProof.
func (mr *MockStoreMockRecorder) ReadSnapVanillaProof(ctx, sr interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadSnapVanillaProof", reflect.TypeOf((*MockStore)(nil).ReadSnapVanillaProof), ctx, sr)
}

// Remove mocks base method.
func (m *MockStore) Remove(ctx context.Context, s abi.SectorID, types storiface.SectorFileType, force bool, keepIn []storiface.ID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Remove", ctx, s, types, force, keepIn)
	ret0, _ := ret[0].(error)
	return ret0
}

// Remove indicates an expected call of Remove.
func (mr *MockStoreMockRecorder) Remove(ctx, s, types, force, keepIn interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Remove", reflect.TypeOf((*MockStore)(nil).Remove), ctx, s, types, force, keepIn)
}

// RemoveCopies mocks base method.
func (m *MockStore) RemoveCopies(ctx context.Context, s abi.SectorID, types storiface.SectorFileType) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveCopies", ctx, s, types)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveCopies indicates an expected call of RemoveCopies.
func (mr *MockStoreMockRecorder) RemoveCopies(ctx, s, types interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveCopies", reflect.TypeOf((*MockStore)(nil).RemoveCopies), ctx, s, types)
}

// Reserve mocks base method.
func (m *MockStore) Reserve(ctx context.Context, sid storiface.SectorRef, ft storiface.SectorFileType, storageIDs storiface.SectorPaths, overheadTab map[storiface.SectorFileType]int, minFreePercentage float64) (func(), error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Reserve", ctx, sid, ft, storageIDs, overheadTab, minFreePercentage)
	ret0, _ := ret[0].(func())
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Reserve indicates an expected call of Reserve.
func (mr *MockStoreMockRecorder) Reserve(ctx, sid, ft, storageIDs, overheadTab, minFreePercentage interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Reserve", reflect.TypeOf((*MockStore)(nil).Reserve), ctx, sid, ft, storageIDs, overheadTab, minFreePercentage)
}

// MockStashStore is a mock of StashStore interface.
type MockStashStore struct {
	ctrl     *gomock.Controller
	recorder *MockStashStoreMockRecorder
}

// MockStashStoreMockRecorder is the mock recorder for MockStashStore.
type MockStashStoreMockRecorder struct {
	mock *MockStashStore
}

// NewMockStashStore creates a new mock instance.
func NewMockStashStore(ctrl *gomock.Controller) *MockStashStore {
	mock := &MockStashStore{ctrl: ctrl}
	mock.recorder = &MockStashStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStashStore) EXPECT() *MockStashStoreMockRecorder {
	return m.recorder
}

// ServeAndRemove mocks base method.
func (m *MockStashStore) ServeAndRemove(ctx context.Context, id uuid.UUID) (io.ReadCloser, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ServeAndRemove", ctx, id)
	ret0, _ := ret[0].(io.ReadCloser)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ServeAndRemove indicates an expected call of ServeAndRemove.
func (mr *MockStashStoreMockRecorder) ServeAndRemove(ctx, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ServeAndRemove", reflect.TypeOf((*MockStashStore)(nil).ServeAndRemove), ctx, id)
}

// StashCreate mocks base method.
func (m *MockStashStore) StashCreate(ctx context.Context, maxSize int64, writeFunc func(*os.File) error) (uuid.UUID, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StashCreate", ctx, maxSize, writeFunc)
	ret0, _ := ret[0].(uuid.UUID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StashCreate indicates an expected call of StashCreate.
func (mr *MockStashStoreMockRecorder) StashCreate(ctx, maxSize, writeFunc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StashCreate", reflect.TypeOf((*MockStashStore)(nil).StashCreate), ctx, maxSize, writeFunc)
}

// StashRemove mocks base method.
func (m *MockStashStore) StashRemove(ctx context.Context, id uuid.UUID) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StashRemove", ctx, id)
	ret0, _ := ret[0].(error)
	return ret0
}

// StashRemove indicates an expected call of StashRemove.
func (mr *MockStashStoreMockRecorder) StashRemove(ctx, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StashRemove", reflect.TypeOf((*MockStashStore)(nil).StashRemove), ctx, id)
}

// StashURL mocks base method.
func (m *MockStashStore) StashURL(id uuid.UUID) (url.URL, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StashURL", id)
	ret0, _ := ret[0].(url.URL)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StashURL indicates an expected call of StashURL.
func (mr *MockStashStoreMockRecorder) StashURL(id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StashURL", reflect.TypeOf((*MockStashStore)(nil).StashURL), id)
}
